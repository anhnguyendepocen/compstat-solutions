## Author: Ruben Dezeure
## In this exercise we want to compare confidence-intervals for nonparametric-regression which are generated by 3 different techniques.
library(boot)
set.seed(11)
dat <- read.table("http://stat.ethz.ch/Teaching/Datasets/parboot.dat")
x <- dat$x
y <- dat$y
x
ind.pre <- seq(5,62,by=3)
x.pre <- x[ind.pre] ## locations where to calculate the confidence intervals
n <- length(x)


## hat-matrix approach
## (without bootstrap)
fit.spline <- smooth.spline(dat$x,dat$y)
## need to do this before so we can use the lambda to get the S matrix!
par(mfrow=c(1,1))
plot(x,dat$y)
lines(x,fitted(fit.spline),lty=3,col="red")

S <- matrix(0,n,n)
In <- diag(n)
for(i in 1:n){
  S[,i] <- fitted(smooth.spline(x,In[,i],spar=fit.spline$spar))
  ##NOW we have the S matrix that corresponds to when we calculate the fit with our input x,y and the parameter lambda tuned to this!
}
df <- sum(diag(S))
fit.y <- fitted(fit.spline)
variance <- sum((y-fit.y)^2)/(n-df)

se <- sqrt(variance*diag(S%*%t(S)))

confint.hat <- cbind(fit.y[ind.pre] - 1.96*se[ind.pre],fit.y[ind.pre] + 1.96*se[ind.pre])
confint.hat

## standard bootstrap (like in series6)

B <- 2000

bootspline <- function(data,ind = 1:nrow(data)){
  yvals <- predict(smooth.spline(data$x[ind],data$y[ind],spar=fit.spline$spar),x.pre)$y
  ##used to be
  ## yvals <- fitted(smooth.spline(data$x[ind],data$y[ind],spar=fit.spline$spar)
  ## yvals[ind.pre]
  ## for some reason this gave problems :/
  ## predict with the x.pre and $y is the safe way
  ## with smooth.spline I guess (or any other methods?)
  ## should always use the same dof for the method!
  yvals
}

##what was used in modelsolution, this I used to *fix* my bootspline method
##fcn.est <- function(dat, ind = 1:nrow(dat))
##predict(smooth.spline(dat$x[ind], dat$y[ind], df = sspl$df), x.pre)$y

##dat <- data.frame(dat$y,dat$x)
boot.std <- boot(dat,statistic=bootspline,R=B)
##boot.std <- boot(dat,statistic=fcn.est,R=B)
##apply(boot.std$t,2,var)
confint.stdboot <- matrix(0,length(ind.pre),2)
for(i in 1:length(ind.pre)){
  
  ci <- boot.ci(boot.std,conf=0.95,type="basic",index = i)
  confint.stdboot[i,] <- c(ci$basic[4],ci$basic[5])
}
confint.stdboot ## contains the confidence intervals from the standard bootstrap

## now parametric bootstrap

ran.parametric <- function(rdata,sigma){
  rdata$y <- fit.y + rnorm(length(fit.y),0,sigma)
  rdata
}

boot.par <- boot(dat,statistic=bootspline,sim="parametric",ran.gen=ran.parametric,mle=sqrt(variance),R=B)

confint.parboot <- matrix(0,length(ind.pre),2)
for(i in 1:length(ind.pre)){
  
  ci <- boot.ci(boot.par,conf=0.95,type="basic",index = i)
  confint.parboot[i,] <- c(ci$basic[4],ci$basic[5])
}
confint.parboot ## contains the confidence intervals from the standard bootstrap

## doing the model based bootstrap

yvals <- fitted(smooth.spline(dat$x,dat$y,spar=fit.spline$spar))
res <- dat$y-yvals
res.centered <- res - mean(res)
ran.model <- function(cdata,centres){
  eps <- sample(centres,length(res.centered),replace=TRUE)
  cdata$y <- yvals+eps ## and now we have our bootstrap sample to use in boot
  cdata
}

boot.model <- boot(dat,statistic=bootspline,sim="parametric",ran.gen=ran.model,R=B,mle=res.centered)

confint.modelboot <- matrix(0,length(ind.pre),2)
for(i in 1:length(ind.pre)){
  
  ci <- boot.ci(boot.model,conf=0.95,type="basic",index = i)
  confint.modelboot[i,] <- c(ci$basic[4],ci$basic[5])
}
confint.modelboot ## contains the confidence intervals from the standard bootstrap

## plots
plot(dat$x,dat$y)
lines(dat$x,fit.y,lty=3,col="red")
realy <- 8*x + 4*cos(14*x)
lines(dat$x,realy,lty=1)
segments(x.pre-0.005,confint.hat[,1],x1=x.pre-0.005,confint.hat[,2],lty=1,col="blue")
segments(x.pre-0,confint.stdboot[,1],x1=x.pre-0,confint.stdboot[,2],lty=1,col="black")
segments(x.pre+0.005,confint.parboot[,1],x1=x.pre+0.005,confint.parboot[,2],lty=1,col="purple")
segments(x.pre+0.010,confint.modelboot[,1],x1=x.pre+0.010,confint.modelboot[,2],lty=1,col="green")

## qqplot
qqnorm(res)
